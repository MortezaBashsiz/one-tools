#!/usr/bin/env ruby

require "yaml"
require "tempfile"
require "erb"
require "pp"

DIR = File.dirname(File.realpath(__FILE__))

################################################################################
# Load OpenNebula
################################################################################

ONE_LOCATION=ENV["ONE_LOCATION"]

if !ONE_LOCATION
    RUBY_LIB_LOCATION = "/usr/lib/one/ruby"
    VAR_LOCATION      = "/var/lib/one"
    LIB_LOCATION      = "/usr/lib/one"
    ETC_LOCATION      = "/etc/one"
else
    RUBY_LIB_LOCATION = ONE_LOCATION + "/lib/ruby"
    VAR_LOCATION      = ONE_LOCATION + "/var"
    LIB_LOCATION      = ONE_LOCATION + "/lib"
    ETC_LOCATION      = ONE_LOCATION + "/etc"
end

$: << RUBY_LIB_LOCATION

require 'opennebula'
include OpenNebula

CLIENT = Client.new

################################################################################
# Read Configuration
################################################################################

yaml_file = ARGV[0] || File.join(DIR, "bootstrap", "default.yaml")

begin
    conf = YAML.load_file(yaml_file)
rescue
    STDERR.puts "'#{yaml_file}' is not a valid yaml file."
end

################################################################################
# Helper
################################################################################

def error(e)
    STDERR.puts e.message
    exit 1
end

###############################################################################
# The TemplateParser Class parses a VM template file and builds a hash with
# the info. It does not check syntax.
###############################################################################

class TemplateParser
    ##########################################################################
    # Patterns to parse the template File
    ##########################################################################

    NAME_REG     =/[\w\d_-]+/
    VARIABLE_REG =/\s*(#{NAME_REG})\s*=\s*/

    SIMPLE_VARIABLE_REG =/#{VARIABLE_REG}([^\[]+?)(#.*)?/
    SINGLE_VARIABLE_REG =/^#{SIMPLE_VARIABLE_REG}$/
    ARRAY_VARIABLE_REG  =/^#{VARIABLE_REG}\[(.*?)\]/m

    ##########################################################################
    ##########################################################################

    def initialize(template_string)
        @conf=parse_conf(template_string)
    end

    def add_configuration_value(key,value)
        add_value(@conf,key,value)
    end

    def [](key)
        @conf[key.to_s.upcase]
    end

    def hash
        @conf
    end

    def self.template_like_str(attributes, indent=true)
         if indent
             ind_enter="\n"
             ind_tab='  '
         else
             ind_enter=''
             ind_tab=' '
         end

         str=attributes.collect do |key, value|
             if value
                 str_line=""
                 if value.class==Array

                     value.each do |value2|
                         str_line << key.to_s.upcase << "=[" << ind_enter
                         if value2 && value2.class==Hash
                             str_line << value2.collect do |key3, value3|
                                 str = ind_tab + key3.to_s.upcase + "="
                                 str += "\"#{value3.to_s}\"" if value3
                                 str
                             end.compact.join(",\n")
                         end
                         str_line << "\n]\n"
                     end

                 elsif value.class==Hash
                     str_line << key.to_s.upcase << "=[" << ind_enter

                     str_line << value.collect do |key3, value3|
                         str = ind_tab + key3.to_s.upcase + "="
                         str += "\"#{value3.to_s}\"" if value3
                         str
                     end.compact.join(",\n")

                     str_line << "\n]\n"

                 else
                     str_line<<key.to_s.upcase << "=" << "\"#{value.to_s}\""
                 end
                 str_line
             end
         end.compact.join("\n")

         str
     end

    ##########################################################################
    ##########################################################################

private


    def san_key(key)
        key.strip.downcase.to_sym
    end

    def san_value(value)
        value.strip.gsub(/"/, '') if value
    end

    #
    #
    #
    def add_value(conf, key, value)
        if conf[key]
            if !conf[key].kind_of?(Array)
                conf[key] = [conf[key]]
            end
            conf[key] << value
        else
            conf[key] = value
        end
    end

    #
    # Parses the configuration file and
    # creates the configuration hash
    #
    def parse_conf(template_string)
        conf=Hash.new

        template_string.scan(SINGLE_VARIABLE_REG) {|m|
            key=san_key(m[0])
            value=san_value(m[1])

            add_value(conf, key, value)
        }

        template_string.scan(ARRAY_VARIABLE_REG) {|m|
            master_key=san_key(m[0])

            pieces=m[1].split(',')

            vars=Hash.new
            pieces.each {|p|
                key, value=p.split('=')
                vars[san_key(key)]=san_value(value)
            }

            add_value(conf, master_key, vars)
        }

        conf
    end
end

################################################################################
# Boostrap Classes
################################################################################

def bsresource(resource)
    begin
        {
          "host"     => BSHost,
          "image"    => BSImage,
          "template" => BSTemplate,
          "net"      => BSNet
        }[resource[:type]].new(resource)
    rescue
        STDERR.puts "Resource '#{resource[:type]}' not supported."
        exit 1
    end
end

class BS
    def initialize(resource)
        @resource = resource
    end

    def do!
        send(@resource[:action])
    end
end

class BSHost < BS
    def create
        h = Host.new(Host.build_xml, CLIENT)

        args = [@resource[:name],
                @resource[:im],
                @resource[:vmm],
                @resource[:vnm]]

        if (cluster_id = @resource[:options][:cluster_id])
            args << cluster_id
        end

        rc = h.allocate(*args)

       error(rc) if OpenNebula.is_error?(rc)
    end
end

class BSImage < BS
    def create
        image = Image.new(Image.build_xml, CLIENT)

        template = TemplateParser.template_like_str(@resource[:template])

        rc = image.allocate(template, @resource[:ds_id])
        error(rc) if OpenNebula.is_error?(rc)
    end
end

class BSNet < BS
    def create
        net = VirtualNetwork.new(VirtualNetwork.build_xml, CLIENT)

        template = TemplateParser.template_like_str(@resource[:template])

        args = [template]

        if (cluster_id = @resource[:options][:cluster_id] rescue nil)
            args << cluster_id
        end

        rc = net.allocate(*args)
        error(rc) if OpenNebula.is_error?(rc)
    end
end

class BSTemplate < BS
    def create
        the_template = Template.new(Template.build_xml, CLIENT)

        template = TemplateParser.template_like_str(@resource[:template])

        rc = the_template.allocate(template)
        error(rc) if OpenNebula.is_error?(rc)
    end
end

################################################################################
# Create Resources
################################################################################

conf.each do |resource|
    r = bsresource(resource)
    r.do!
end
