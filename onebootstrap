#!/usr/bin/env ruby

require "yaml"
require "tempfile"
require "erb"
require "pp"

begin
    require "colored"
    COLORED=true
rescue
    COLORED=false
end

DIR = File.dirname(File.realpath(__FILE__))

################################################################################
# Load OpenNebula
################################################################################

ONE_LOCATION=ENV["ONE_LOCATION"]

if !ONE_LOCATION
    RUBY_LIB_LOCATION = "/usr/lib/one/ruby"
    VAR_LOCATION      = "/var/lib/one"
    LIB_LOCATION      = "/usr/lib/one"
    ETC_LOCATION      = "/etc/one"
else
    RUBY_LIB_LOCATION = ONE_LOCATION + "/lib/ruby"
    VAR_LOCATION      = ONE_LOCATION + "/var"
    LIB_LOCATION      = ONE_LOCATION + "/lib"
    ETC_LOCATION      = ONE_LOCATION + "/etc"
end

$: << RUBY_LIB_LOCATION

require 'opennebula'
include OpenNebula

CLIENT = Client.new

################################################################################
# Read Configuration
################################################################################

yaml_file = ARGV[0] || File.join(DIR, "bootstrap", "default.yaml")

begin
    conf = YAML.load_file(yaml_file)
rescue
    STDERR.puts "'#{yaml_file}' is not a valid yaml file."
    exit 1
end

################################################################################
# Helper
################################################################################

def error(e)
    if e.instance_of?(String)
        STDERR.puts e
    else
        STDERR.puts e.message
    end
end

def log(e, level=nil)
    if COLORED
        m = case level
        when :ok
            e.green
        when :warn
            e.cyan
        when :info
            e.blue
        when :error
            e.red
        else
            e
        end
    else
        m = e
    end

    puts m
end

###############################################################################
# The TemplateParser Class parses a VM template file and builds a hash with
# the info. It does not check syntax.
###############################################################################

class TemplateParser
    ##########################################################################
    # Patterns to parse the template File
    ##########################################################################

    NAME_REG     =/[\w\d_-]+/
    VARIABLE_REG =/\s*(#{NAME_REG})\s*=\s*/

    SIMPLE_VARIABLE_REG =/#{VARIABLE_REG}([^\[]+?)(#.*)?/
    SINGLE_VARIABLE_REG =/^#{SIMPLE_VARIABLE_REG}$/
    ARRAY_VARIABLE_REG  =/^#{VARIABLE_REG}\[(.*?)\]/m

    ##########################################################################
    ##########################################################################

    def initialize(template_string)
        @conf=parse_conf(template_string)
    end

    def add_configuration_value(key,value)
        add_value(@conf,key,value)
    end

    def [](key)
        @conf[key.to_s.upcase]
    end

    def hash
        @conf
    end

    def self.template_like_str(attributes, indent=true)
         if indent
             ind_enter="\n"
             ind_tab='  '
         else
             ind_enter=''
             ind_tab=' '
         end

         str=attributes.collect do |key, value|
             if value
                 str_line=""
                 if value.class==Array

                     value.each do |value2|
                         str_line << key.to_s.upcase << "=[" << ind_enter
                         if value2 && value2.class==Hash
                             str_line << value2.collect do |key3, value3|
                                 str = ind_tab + key3.to_s.upcase + "="
                                 str += "\"#{value3.to_s}\"" if value3
                                 str
                             end.compact.join(",\n")
                         end
                         str_line << "\n]\n"
                     end

                 elsif value.class==Hash
                     str_line << key.to_s.upcase << "=[" << ind_enter

                     str_line << value.collect do |key3, value3|
                         str = ind_tab + key3.to_s.upcase + "="
                         str += "\"#{value3.to_s}\"" if value3
                         str
                     end.compact.join(",\n")

                     str_line << "\n]\n"

                 else
                     str_line<<key.to_s.upcase << "=" << "\"#{value.to_s}\""
                 end
                 str_line
             end
         end.compact.join("\n")

         str
     end

    ##########################################################################
    ##########################################################################

private


    def san_key(key)
        key.strip.downcase.to_sym
    end

    def san_value(value)
        value.strip.gsub(/"/, '') if value
    end

    #
    #
    #
    def add_value(conf, key, value)
        if conf[key]
            if !conf[key].kind_of?(Array)
                conf[key] = [conf[key]]
            end
            conf[key] << value
        else
            conf[key] = value
        end
    end

    #
    # Parses the configuration file and
    # creates the configuration hash
    #
    def parse_conf(template_string)
        conf=Hash.new

        template_string.scan(SINGLE_VARIABLE_REG) {|m|
            key=san_key(m[0])
            value=san_value(m[1])

            add_value(conf, key, value)
        }

        template_string.scan(ARRAY_VARIABLE_REG) {|m|
            master_key=san_key(m[0])

            pieces=m[1].split(',')

            vars=Hash.new
            pieces.each {|p|
                key, value=p.split('=')
                vars[san_key(key)]=san_value(value)
            }

            add_value(conf, master_key, vars)
        }

        conf
    end
end

################################################################################
# Boostrap Classes
################################################################################


class BS
    def initialize(resource)
        @resource = resource
    end

    def to_s
        name = @resource[:name] || @resource[:template][:name] rescue nil

        "@type:#{@resource[:type]}/@name:#{name}"
    end

    def do!
        log("* #{self}", :info)

        case action = @resource[:action].to_sym
        when :create
            if !exists?
                log("> Creating", :ok)
                send(action)
            else
                log("> Skipping: resource exists", :warn)
            end
        else
            error("Unknown action: '#{action}'.")
        end
    end

    def exists?
        name = @resource[:name] || @resource[:template][:name] rescue nil
        if name.nil?
            error("Field 'NAME' missing from resource")
            return true
        end

        pool = BSRESOURCES[@resource[:type]][:pool].new(CLIENT)
        rc = pool.info
        error(rc) if OpenNebula.is_error?(rc)

        pool.each do |e|
            return true if e["NAME"] == name
        end

        return false
    end
end

class BSHost < BS
    def create
        h = Host.new(Host.build_xml, CLIENT)

        args = [@resource[:name],
                @resource[:im],
                @resource[:vmm],
                @resource[:vnm]]

        if (cluster_id = @resource[:cluster_id])
            args << cluster_id
        end

        rc = h.allocate(*args)

       error(rc) if OpenNebula.is_error?(rc)
    end
end

class BSImage < BS
    def create
        image = Image.new(Image.build_xml, CLIENT)

        template = TemplateParser.template_like_str(@resource[:template])

        rc = image.allocate(template, @resource[:ds_id])
        error(rc) if OpenNebula.is_error?(rc)
    end
end

class BSNet < BS
    def create
        net = VirtualNetwork.new(VirtualNetwork.build_xml, CLIENT)

        template = TemplateParser.template_like_str(@resource[:template])

        args = [template]

        if (cluster_id = @resource[:cluster_id] rescue nil)
            args << cluster_id
        end

        rc = net.allocate(*args)
        error(rc) if OpenNebula.is_error?(rc)
    end
end

class BSDatastore < BS
    def create
        ds = Datastore.new(Datastore.build_xml, CLIENT)

        template = TemplateParser.template_like_str(@resource[:template])

        args = [template]

        if (cluster_id = @resource[:cluster_id] rescue nil)
            args << cluster_id
        end

        rc = ds.allocate(*args)
        error(rc) if OpenNebula.is_error?(rc)
    end
end

class BSTemplate < BS
    def create
        the_template = Template.new(Template.build_xml, CLIENT)

        template = TemplateParser.template_like_str(@resource[:template])

        rc = the_template.allocate(template)
        error(rc) if OpenNebula.is_error?(rc)
    end
end

class BSUser < BS
    def create
        user = User.new(User.build_xml, CLIENT)

        args = [@resource[:name], @resource[:password]]

        if (driver = @resource[:driver])
            args << driver
        end

        rc = user.allocate(*args)
        error(rc) if OpenNebula.is_error?(rc)
    end
end

BSRESOURCES = {
    "host"      => {:bs => BSHost, :pool => HostPool},
    "image"     => {:bs => BSImage, :pool => ImagePool},
    "template"  => {:bs => BSTemplate, :pool => TemplatePool},
    "net"       => {:bs => BSNet, :pool => VirtualNetworkPool},
    "datastore" => {:bs => BSDatastore, :pool => DatastorePool},
    "user"      => {:bs => BSUser, :pool => UserPool}
}

def bsresource(resource)
    begin
        BSRESOURCES[resource[:type]][:bs].new(resource)
    rescue
        error("Resource '#{resource[:type]}' not supported.")
    end
end

################################################################################
# Create Resources
################################################################################

conf.each do |resource|
    r = bsresource(resource)
    r.do!
end
